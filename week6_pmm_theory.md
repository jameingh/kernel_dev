# 第三阶段·物理内存管理（PMM）理论：从发明者视角的推导

> 目标：为什么需要“物理页管理”？在无分页或早期分页阶段，如何构造一个可验证、可扩展的物理内存分配与回收系统。站在发明者的视角，从问题到约束，再到方案与接口，一步步推导。

## 问题动机
- 资源稀缺与秩序：裸机环境中，任何越界写都会腐蚀内核或设备映射区；需要“谁能使用哪块内存”的秩序。
- 扩展的必然性：从 1MB 实模式到几十/几百 MB 甚至更大，必须有系统化的页级管理，未来分页与伙伴系统都要依赖它。
- 可验证的最小系统：先有一个“页级租借系统”，能统计、能分配、能回收；再逐步叠加复杂特性（NUMA、DMA、巨大页）。

## 硬件与启动约束
- 页粒度：以 4KB 为基本单位（x86 传统页大小），便于与分页机制对齐。
- 关键保留区域：
  - 低端内存：BIOS/设备映射、VGA 文本模式 `0xB8000`、中断向量表等历史区域。
  - 内核与数据：本项目将内核加载到 `0x10000`，需要标记内核所占物理范围为“已占用”。
  - 引导区与 GDT/IDT：内核运行时这些结构会常驻，需标记保留。
- 内存发现：
  - 理想：使用 BIOS `E820`（`int 0x15, EAX=0xE820`）获得物理内存映射（type=1 为可用 RAM）。
  - 过渡：在没有 E820 的实现前，可采用“预设物理上限 + 手动保留区”开展 PMM 的接口与验证。

## 设计目标（以最小正确为先）
- 正确性：不分配保留区，不越界；统计一致。
- 简洁性：初始化 O(N)；分配/释放尽量 O(1) 或摊还近似 O(1)。
- 可扩展：能平滑接入 E820，能支持连续页分配与对齐。

## 方案选择与推导
- 方案备选：
  - 位图（bitmap）：每页 1 bit，0=占用，1=可用。优点：空间小、遍历快；缺点：查找连续块需线性扫描。
  - 空闲栈（free list/stack）：将空闲页的物理页号（PFN）压栈。优点：分配/释放 O(1)；缺点：连续块分配与合并复杂。
- 本阶段选择：位图优先（更直观、统计简单）；可在后续加入“空闲栈”作为快速路径。

### 位图布局与放置
- 位图大小计算：`bitmap_bytes = ceil(total_pages / 8)`；例如 64MB 物理内存约 `64*1024 / 4 = 16384` 页，位图约 `2KB`。
- 位图放置原则：
  - 放在内核镜像末尾或预留的“管理区”中，避免与用户/驱动数据碰撞。
  - 记录其物理地址范围，并在初始化时将位图自身标记为“占用”。

### 初始化步骤（无 E820 版本）
1) 设定一个物理内存上限 `pmm_total_bytes`（例如 QEMU 默认 128MB，可通过命令行指定）。
2) 计算页数与位图大小，将位图放置到内核末尾的对齐地址（暂以链接脚本或静态数组预留实现）。
3) 将所有页标记为可用（1），然后对保留区执行“占用（0）”标记：
   - `0x00000000–0x0009FFFF` 低端传统区
   - `0x000A0000–0x000BFFFF` VGA/视频内存
   - `内核镜像范围`（从 `0x00100000` 或本项目的 `0x00010000` 起，按实际大小）
   - 位图所在区域
4) 维护统计：`pmm_total_pages`、`pmm_free_pages`。

### 分配与回收接口（函数名引用）
- `pmm_init`：初始化位图与统计（后续接入 `E820` 解析）。
- `pmm_alloc_page`：分配 1 页，返回物理地址；若无可用页返回 0。
- `pmm_free_page`：释放 1 页（物理地址必须按 4KB 对齐且非保留区）。
- `pmm_alloc_contiguous(n)`：分配 n 连续页（线性扫描位图的连续 1 区段）。
- `pmm_total_pages` / `pmm_free_pages`：查询总页与空闲页统计。

## 与后续组件的契合
- 与分页（VMM）：位图返回的物理地址将用于填充页表项（PTE），形成物理到线性地址映射；PMM 是 VMM 的底座。
- 与内核堆：当启用分页后，可在高地址建立 `kmalloc`/`kfree`；早期也可用“连续页”作为简单堆的后备。
- 与设备与 DMA：后续可扩展“指定地址范围的分配”（如低 16MB 的 DMA 约束）。

## 校验与可视化建议
- 启动时打印 PMM 统计：`total_pages/free_pages`，并在状态栏增加 `MemFree: xxxxx`（固定宽度）。
- 连续页分配/释放自检：分配 n 页，打印起始物理地址与释放后的统计变化。
- 压力测试：循环分配与释放随机大小的页块，确保统计与位图一致。

## 与本项目当前布局的映射
- 启动与初始化：在 `kernel.c:kmain` 中调用 `pmm_init`，随后保留现有的 `idt_init/isr_init/irq_init/pit_init` 与 `sti`。
- 终端输出：在 `terminal.c` 的接口基础上输出 PMM 统计；状态栏可选择性展示内存信息。
- 未来接入 E820：在 `boot.asm` 的 16 位阶段调用 `int 0x15, EAX=0xE820` 填充内存映射表，并在切到 32 位后传递给 `pmm_init`。

## 小结：从“秩序”到“扩展”的发明路径
- 第一步：建立页级“秩序”（位图），确保分配/回收与统计正确可见。
- 第二步：接入真实内存映射（E820），将保留/可用区从硬件事实推导出来。
- 第三步：叠加连续/对齐分配、DMA 约束与快速路径（空闲栈）。
- 第四步：与分页、堆、文件缓存等子系统融合，形成稳定的内存管理骨架。

---

### 术语表
- PFN（Page Frame Number）：物理页号；`PFN = phys_addr / 4096`。
- E820：BIOS 提供的内存映射接口，返回多个区域（可用、保留、ACPI 等）。
- 位图：以位标识状态的数据结构，空间紧凑，适合全局资源的启用/禁用管理。

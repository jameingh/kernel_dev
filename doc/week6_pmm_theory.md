# 第三阶段·物理内存管理（PMM）理论：从发明者视角的推导

> 目标：为什么需要“物理页管理”？在无分页或早期分页阶段，如何构造一个可验证、可扩展的物理内存分配与回收系统。站在发明者的视角，从问题到约束，再到方案与接口，一步步推导。

## 问题动机
- 资源稀缺与秩序：裸机环境中，任何越界写都会腐蚀内核或设备映射区；需要“谁能使用哪块内存”的秩序。
- 扩展的必然性：从 1MB 实模式到几十/几百 MB 甚至更大，必须有系统化的页级管理，未来分页与伙伴系统都要依赖它。
- 可验证的最小系统：先有一个“页级租借系统”，能统计、能分配、能回收；再逐步叠加复杂特性（NUMA、DMA、巨大页）。

## 硬件与启动约束
- 页粒度：以 4KB 为基本单位（x86 传统页大小），便于与分页机制对齐。
- 关键保留区域：
  - 低端内存：BIOS/设备映射、VGA 文本模式 `0xB8000`、中断向量表等历史区域。
  - 内核与数据：本项目将内核加载到 `0x10000`，需要标记内核所占物理范围为“已占用”。
  - 引导区与 GDT/IDT：内核运行时这些结构会常驻，需标记保留。
- 内存发现：
  - 理想：使用 BIOS `E820`（`int 0x15, EAX=0xE820`）获得物理内存映射（type=1 为可用 RAM）。
  - 过渡：在没有 E820 的实现前，可采用“预设物理上限 + 手动保留区”开展 PMM 的接口与验证。

## 设计目标（以最小正确为先）
- 正确性：不分配保留区，不越界；统计一致。
- 简洁性：初始化 O(N)；分配/释放尽量 O(1) 或摊还近似 O(1)。
- 可扩展：能平滑接入 E820，能支持连续页分配与对齐。

## 方案选择与推导
- 方案备选：
  - 位图（bitmap）：每页 1 bit，0=占用，1=可用。优点：空间小、遍历快；缺点：查找连续块需线性扫描。
  - 空闲栈（free list/stack）：将空闲页的物理页号（PFN）压栈。优点：分配/释放 O(1)；缺点：连续块分配与合并复杂。
- 本阶段选择：位图优先（更直观、统计简单）；可在后续加入“空闲栈”作为快速路径。

![PMM Layout](/imgs/pmm_memory_layout_diagram_1766470125355.png)

### 图解：物理内存就像酒店管理
- **左侧（物理内存/房间）**：
  - **红色（保留区）**：BIOS/VGA/内核区。这些是“非卖品”，绝对不可分配。
  - **蓝色（内核）**：操作系统核心代码驻留地。
  - **橙色（位图）**：管理数据本身也占空间。
  - **绿色（可用）**：真正可供分配的空闲内存。
- **右侧（位图/账本）**：
  - **1 bit = 1 Page (4KB)**。
  - **置 0**：表示“占用”或“保留”。
  - **置 1**：表示“空闲”。
  - 初始化就是把左边的物理事实，翻译成右边的 `0/1` 状态。


### 位图布局与放置
- 位图大小计算：`bitmap_bytes = ceil(total_pages / 8)`；例如 64MB 物理内存约 `64*1024 / 4 = 16384` 页，位图约 `2KB`。
- 位图放置原则：
  - 放在内核镜像末尾或预留的“管理区”中，避免与用户/驱动数据碰撞。
  - 记录其物理地址范围，并在初始化时将位图自身标记为“占用”。

### 初始化步骤（无 E820 版本）
1) 设定一个物理内存上限 `pmm_total_bytes`（例如 QEMU 默认 128MB，可通过命令行指定）。
2) 计算页数与位图大小，将位图放置到内核末尾的对齐地址（暂以链接脚本或静态数组预留实现）。
3) 将所有页标记为可用（1），然后对保留区执行“占用（0）”标记：
   - `0x00000000–0x0009FFFF` 低端传统区
   - `0x000A0000–0x000BFFFF` VGA/视频内存
   - `内核镜像范围`（从 `0x00100000` 或本项目的 `0x00010000` 起，按实际大小）
   - 位图所在区域
4) 维护统计：`pmm_total_pages`、`pmm_free_pages`。

![PMM Init Flow](/imgs/pmm_init_flow_diagram_1766472003530.png)

### 流程拆解
1.  **Set Limit**：根据物理探测或手动设定，划定这是一个多大的“酒店”（如 128MB）。
2.  **Calc Size**：计算需要多少页（32768页），需要多大的账本（位图 4KB）。
3.  **Place Bitmap**：在内存中给账本找个安身之所（通常在内核末尾）。
4.  **Mark All 1**：先假设世界是美好的，所有房间都空着。
5.  **Mark Reserved 0**：回归现实，把被 BIOS、VGA、内核占用的房间涂黑（置 0）。
6.  **Stats**：统计一下到底还剩多少绿色的“1”。

### 分配与回收接口（函数名引用）
- `pmm_init`：初始化位图与统计（后续接入 `E820` 解析）。
- `pmm_alloc_page`：分配 1 页，返回物理地址；若无可用页返回 0。
- `pmm_free_page`：释放 1 页（物理地址必须按 4KB 对齐且非保留区）。
- `pmm_alloc_contiguous(n)`：分配 n 连续页（线性扫描位图的连续 1 区段）。
- `pmm_total_pages` / `pmm_free_pages`：查询总页与空闲页统计。

![Alloc/Free Logic](/imgs/pmm_alloc_free_diagram_1766472024876.png)

### 操作逻辑
- **Alloc Page (上图)**：
  - 拿着放大镜（线性扫描）在位图里找第一个绿色的 `1`。
  - 找到后，立马涂成橙色 `0`（表示刚被你订了）。
  - 返回这个 bit 对应的物理地址。
- **Free Page (中图)**：
  - 拿着物理地址算出是第几个 bit。
  - 把它涂回绿色 `1`（退房）。
- **Alloc Contiguous (下图)**：
  - 这是一个“连号房间”的需求。
  - 扫描位图，寻找一段连续 `n` 个都是 `1` 的窗口。
  - 找到后把这 `n` 个 bit 全涂成 `0`。

## 与后续组件的契合
- 与分页（VMM）：位图返回的物理地址将用于填充页表项（PTE），形成物理到线性地址映射；PMM 是 VMM 的底座。
- 与内核堆：当启用分页后，可在高地址建立 `kmalloc`/`kfree`；早期也可用“连续页”作为简单堆的后备。
- 与设备与 DMA：后续可扩展“指定地址范围的分配”（如低 16MB 的 DMA 约束）。

## 校验与可视化建议
- 启动时打印 PMM 统计：`total_pages/free_pages`，并在状态栏增加 `MemFree: xxxxx`（固定宽度）。
- 连续页分配/释放自检：分配 n 页，打印起始物理地址与释放后的统计变化。
- 压力测试：循环分配与释放随机大小的页块，确保统计与位图一致。

![Status Bar Mockup](/imgs/os_status_bar_mockup_1766472042599.png)

### 状态栏联动
- 实现一个常驻屏幕顶端的状态栏（利用 VGA 显存特定区域）。
- 实时显示 `MemFree`，当你调用 `pmm_alloc` 时数字减小，`pmm_free` 时数字增加。
- 这是最直观的“系统心跳”证明。

## 与本项目当前布局的映射
- 启动与初始化：在 `kernel.c:kmain` 中调用 `pmm_init`，随后保留现有的 `idt_init/isr_init/irq_init/pit_init` 与 `sti`。
- 终端输出：在 `terminal.c` 的接口基础上输出 PMM 统计；状态栏可选择性展示内存信息。
- 未来接入 E820：在 `boot.asm` 的 16 位阶段调用 `int 0x15, EAX=0xE820` 填充内存映射表，并在切到 32 位后传递给 `pmm_init`。

## 小结：从“秩序”到“扩展”的发明路径
- 第一步：建立页级“秩序”（位图），确保分配/回收与统计正确可见。
- 第二步：接入真实内存映射（E820），将保留/可用区从硬件事实推导出来。
- 第三步：叠加连续/对齐分配、DMA 约束与快速路径（空闲栈）。
- 第四步：与分页、堆、文件缓存等子系统融合，形成稳定的内存管理骨架。

---

### 术语表
- PFN（Page Frame Number）：物理页号；`PFN = phys_addr / 4096`。
- E820：BIOS 提供的内存映射接口，返回多个区域（可用、保留、ACPI 等）。
- 位图：以位标识状态的数据结构，空间紧凑，适合全局资源的启用/禁用管理。

---

## MVP 与可选优化

### 为什么当前实现满足 MVP
- 目标聚焦：当前内核已具备引导、GDT/IDT、PIC/IRQ、PIT、键盘输入、终端输出、基础 PMM 统计与页级分配/释放能力。
- 简化假设：使用固定物理上限与位图即可保证“有序分配与回收”，不依赖复杂硬件映射，足以支撑后续分页与简单内核堆接入。
- 可视验证：通过终端日志与状态栏 `MemFree` 显示实时统计，行为可见、易于调试。

### 后期可选优化（暂不实现）
- 接入 E820：在 `boot.asm` 的 16 位阶段采集内存映射并传递到 32 位后用于 `pmm_init`，形成“硬件真实的可用/保留区”。
- 连续分配优化：为 `pmm_alloc_contiguous` 提供更快的查找策略（例如跳过非空闲段的块索引或使用区间树/跳表）。
- DMA/对齐约束：新增“指定地址范围”的分配接口（如低 16MB、对齐到 64KB），满足设备与驱动需求。

说明：以上优化不影响当前 MVP 的正确性与教学目标，可在进入分页与驱动阶段时逐步引入。

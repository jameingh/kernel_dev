这个问题非常关键，涉及到程序是如何从“碎片”变成“整体”的。

这两行 extern 的作用可以通俗地理解为：“向编译器申请一个外部链接的坑位”。

## 1. extern 指令的意思
- 字面含义：extern 是 External（外部）的缩写。
- 语义：它告诉汇编编译器（nasm）：“嘿，兄弟，我要调用一个叫 
**isr_handler**的东西。虽然它不在我这个**isr.asm**文件里定义，但你先别报错，在编译出的二进制文件里给我留个白（坑位），以后会有人来填它的。”
## 2. 它是如何连上 C 函数的？
这是一个分步合作的过程：

1. 第一步：独立编译
    - 汇编编译器 (nasm) 把 **isr.asm** 变成 isr.o。此时 **isr_handler** 的地址是“未定义的”，在那儿留了个空位。
    - C 编译器 (gcc) 把 **interrupts.c** 变成 interrupts.o。它里面定义了 **isr_handler** 函数，并标记了它的位置。
2. 第二步：链接 (Linking) —— 关键点
    - 在 build.sh 里调用的 **ld**（链接器） 就是最后的“媒婆”。
    - 链接器把 isr.o 和 interrupts.o 放在一起。它看到汇编里有个叫 **isr_handler** 的“坑位”，又看到 C 语言里有个叫 **isr_handler** 的真实函数。
    - 链接器大手一挥，把 C 函数的真实起始地址 填到了汇编留下的那个“坑位”里。
3. 为什么名字能对上？
    - 在 32 位 x86 开发中，C 语言编译后的符号名通常就是函数名本身（或者前面加个下划线 _）。只要你在 C 语言里写了 void isr_handler(...)，在汇编里写 extern isr_handler，名字一模一样，链接器就能精准地把它们“缝合”在一起。

总结： extern 就像汇编向 C 语言发出的**跨时空通话申请**，而链接器（Linker）就是负责接线并把电话拨通的那个人。